import{$ as R,I as C,a0 as E,a1 as T,a2 as $,a3 as O,a4 as F,S as L,a5 as S,q as U,a6 as q,C as z,a7 as p,a8 as B,a9 as j,aa as H,k as M,ab as I,y as x,z as A}from"./entry.QegfnR5A.js";const K=r=>r==="defer"||r===!1;function G(...r){var D;const o=typeof r[r.length-1]=="string"?r.pop():void 0;typeof r[0]!="string"&&r.unshift(o);let[a,s,e={}]=r;if(typeof a!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof s!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const t=L(),u=s,m=()=>null,y=()=>t.isHydrating?t.payload.data[a]:t.static.data[a];e.server=e.server??!0,e.default=e.default??m,e.getCachedData=e.getCachedData??y,e.lazy=e.lazy??!1,e.immediate=e.immediate??!0,e.deep=e.deep??R.deep,e.dedupe=e.dedupe??"cancel";const _=()=>![null,void 0].includes(e.getCachedData(a));if(!t._asyncData[a]||!e.immediate){(D=t.payload._errors)[a]??(D[a]=null);const c=e.deep?C:E;t._asyncData[a]={data:c(e.getCachedData(a)??e.default()),pending:C(!_()),error:T(t.payload._errors,a),status:C("idle")}}const n={...t._asyncData[a]};n.refresh=n.execute=(c={})=>{if(t._asyncDataPromises[a]){if(K(c.dedupe??e.dedupe))return t._asyncDataPromises[a];t._asyncDataPromises[a].cancelled=!0}if((c._initial||t.isHydrating&&c._initial!==!1)&&_())return Promise.resolve(e.getCachedData(a));n.pending.value=!0,n.status.value="pending";const f=new Promise((i,l)=>{try{i(u(t))}catch(b){l(b)}}).then(i=>{if(f.cancelled)return t._asyncDataPromises[a];let l=i;e.transform&&(l=e.transform(i)),e.pick&&(l=N(l,e.pick)),t.payload.data[a]=l,n.data.value=l,n.error.value=null,n.status.value="success"}).catch(i=>{if(f.cancelled)return t._asyncDataPromises[a];n.error.value=S(i),n.data.value=U(e.default()),n.status.value="error"}).finally(()=>{f.cancelled||(n.pending.value=!1,delete t._asyncDataPromises[a])});return t._asyncDataPromises[a]=f,t._asyncDataPromises[a]};const g=()=>n.refresh({_initial:!0}),w=e.server!==!1&&t.payload.serverRendered;{const c=q();if(c&&!c._nuxtOnBeforeMountCbs){c._nuxtOnBeforeMountCbs=[];const i=c._nuxtOnBeforeMountCbs;c&&($(()=>{i.forEach(l=>{l()}),i.splice(0,i.length)}),O(()=>i.splice(0,i.length)))}w&&t.isHydrating&&(n.error.value||_())?(n.pending.value=!1,n.status.value=n.error.value?"error":"success"):c&&(t.payload.serverRendered&&t.isHydrating||e.lazy)&&e.immediate?c._nuxtOnBeforeMountCbs.push(g):e.immediate&&g(),e.watch&&F(e.watch,()=>n.refresh());const f=t.hook("app:data:refresh",async i=>{(!i||i.includes(a))&&await n.refresh()});c&&O(f)}const v=Promise.resolve(t._asyncDataPromises[a]).then(()=>n);return Object.assign(v,n),v}function N(r,o){const a={};for(const s of o)a[s]=r[s];return a}function V(r,o,a){const[s={},e]=typeof o=="string"?[{},o]:[o,a],t=z(()=>{let h=r;return typeof h=="function"&&(h=h()),p(h)}),u=s.key||B([e,typeof t.value=="string"?t.value:"",...J(s)]);if(!u||typeof u!="string")throw new TypeError("[nuxt] [useFetch] key must be a string: "+u);if(!r)throw new Error("[nuxt] [useFetch] request is missing.");const m=u===e?"$f"+u:u;if(!s.baseURL&&typeof t.value=="string"&&t.value[0]==="/"&&t.value[1]==="/")throw new Error('[nuxt] [useFetch] the request URL must not start with "//".');const{server:y,lazy:_,default:n,transform:g,pick:w,watch:v,immediate:D,getCachedData:c,deep:f,...i}=s,l=j({...H,...i,cache:typeof s.cache=="boolean"?void 0:s.cache}),b={server:y,lazy:_,default:n,transform:g,pick:w,immediate:D,getCachedData:c,deep:f,watch:v===!1?[]:[l,t,...v||[]]};let d;return G(m,()=>{var k;(k=d==null?void 0:d.abort)==null||k.call(d),d=typeof AbortController<"u"?new AbortController:{};const h=p(s.timeout);return h&&setTimeout(()=>d.abort(),h),(s.$fetch||globalThis.$fetch)(t.value,{signal:d.signal,...l})},b)}function J(r){var a;const o=[((a=p(r.method))==null?void 0:a.toUpperCase())||"GET",p(r.baseURL)];for(const s of[r.params||r.query]){const e=p(s);if(!e)continue;const t={};for(const[u,m]of Object.entries(e))t[p(u)]=p(m);o.push(t)}return o}const P=(r,o)=>{const{access:a}=Q(),e=M().public.baseURL,t=new Headers,u=`${e}${r}`;return V(u,{...o,async onRequest({request:m,options:y}){a&&t.set("Authorization","Bearer "+a),y.headers=t}},"$sC22i8rhLA")},Q=I("auth",{state:()=>({username:null,email_valid:!1,password1_valid:!1,isAuthenticated:!1,non_field_errors:!1,firstname_valid:!1,lastname_valid:!1,access:null,refresh_token:null}),persist:!0,actions:{async login(r,o){try{const a=await P("api/token/",{method:"POST",body:r});if(a.status.value==="success"){const s=a.data.value;this.username=s.first_name?s.first_name:s.username,this.access=s.access,this.refresh_token=s.refresh,this.isAuthenticated=!0;const e=x(),t=A();e.push({path:t("/")})}if(a.status.value==="error"){this.isAuthenticated=!1;const s=a.error.value.data;this.email_valid=s.email?s.email[0]:!1,this.password1_valid=s.password?s.password[0]:!1,o()}}catch(a){console.error("Error:",a)}},async register(r,o,a){try{const s=await P("auth/register/",{method:"POST",body:r});if(console.log(s),s.status.value==="success"){const e=s.data.value;this.user=e.user;const t=x(),u=A();t.push({path:u("login")}),o()}if(s.status.value==="error"){const e=s.error.value.data;this.non_field_errors=e.non_field_errors?e.non_field_errors[0]:!1,this.email_valid=e.email?e.email[0]:!1,this.firstname_valid=e.first_name?e.first_name[0]:!1,this.lastname_valid=e.last_name?e.last_name[0]:!1,this.password1_valid=e.password1?e.password1[0]:!1,a()}}catch(s){console.error("Error",s)}},async refresh(){try{const r=new FormData;r.append("refresh",this.refresh_token);const o=await P("api/token/refresh/",{method:"POST",body:r});if(o.status.value==="success"){const a=o.data.value;this.access=a.access,this.refresh_token=a.refresh,this.isAuthenticated=!0}o.status.value==="error"&&(this.isAuthenticated=!1)}catch(r){console.error("Error:",r)}}}});export{Q as a};
